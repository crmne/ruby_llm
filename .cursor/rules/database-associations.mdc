---
description:
globs:
alwaysApply: false
---

# Database Association Best Practices

This rule covers best practices for ActiveRecord associations in the Ruby LLM codebase.

## Foreign Key Constraints

For database integrity, use foreign key constraints at the database level, not just in Rails models:

```ruby
# In your migrations:
add_foreign_key :child_table, :parent_table
```

Options for managing referential integrity:

- `on_delete: :cascade` - Automatically delete dependent records
- `on_delete: :nullify` - Set foreign key to NULL
- `on_delete: :restrict` - Prevent deletion if dependent records exist

## Association Declarations

When using `belongs_to`, consider:

1. Setting `optional: true` for nullable foreign keys:

```ruby
belongs_to :parent, optional: true
```

2. Adding appropriate foreign key and inverse_of options:

```ruby
belongs_to :parent,
           foreign_key: 'parent_id',
           inverse_of: :children
```

3. Using `touch: true` when relevant:

```ruby
belongs_to :chat, touch: true # Updates parent timestamps
```

## Example from the Codebase

In [lib/ruby_llm/active_record/acts_as.rb](mdc:lib/ruby_llm/active_record/acts_as.rb), we use:

```ruby
belongs_to :parent_tool_call,
           class_name: @tool_call_class,
           foreign_key: 'tool_call_id',
           optional: true,
           inverse_of: :result
```

## Dependent Options

For `has_many` and `has_one` associations:

```ruby
has_many :messages, dependent: :destroy
has_one :result, dependent: :nullify
```

Options:

- `:destroy` - Calls destroy on associated objects
- `:delete_all` - Deletes without callbacks
- `:nullify` - Sets foreign key to NULL
- `:restrict_with_exception` - Raises error if associations exist

## Best Practice Summary

1. Always define both database constraints AND model validations
2. Use `inverse_of` to improve performance and prevent object duplication
3. Consider impact on performance for large associations
4. Use transactions for operations involving multiple models
